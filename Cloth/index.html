<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>Cloth</title>
        <link type="text/css" rel="stylesheet" href="style.css">
	</head>
	<body>

        <div id="container"></div>
        <div id="info"></div>
        <script async src="https://ga.jspm.io/npm:es-module-shims@1.5.17/dist/es-module-shims.js"></script>
        <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.144.0/build/three.module.js",
                "three/addons/": "./jsm/"
            }
        }
        </script>
        
		<script type="module">

            // Load module
            import * as THREE from "three"
            import Stats from "three/addons/libs/stats.module.js"
            import { TrackballControls } from "three/addons/controls/TrackballControls.js"
            import { GUI } from 'three/addons/libs/lil-gui.module.min.js'
            import { TextGeometry  } from 'three/addons/geometries/TextGeometry.js'
            import { OBJLoader  } from 'three/addons/loaders/OBJLoader.js'

            // Simulater variables
            let camera, scene, renderer, controls, stats
            const clock = new THREE.Clock()
            let h_count = 0
            let face_len = 0
            
            // Physic variables
            const air_resitance = 0.01
            const gravity = -9.8
            const spring = 10
            const damping = 1

            // Object variables
            let plane
            
            let cloth, cloth_geo, cloth_corners
            let cloth_pos = new THREE.Vector3(0, 10, 0)
            let cloth_move = 0
            let cloth_dense = 10
            const node_num = (cloth_dense + 1) ** 2
            let node_v = []
            let cloth_edges = []
            const cloth_mass = 2
            
            // GUI params
            const canvas = document.querySelector("#container")
            const params = {
                pts_num: 300,
                k_avoid: 10,
                k_vmatch: 10,
                k_center: 1,
                r1: 3,
                r2: 30,
                obstacles: true,
                moving: true,
				Reset: function () {
                    renderer.domElement.remove()
                    init()
				}
			}
            
            
			init()
			animate()

            function init() {

                // Init scene
                scene = new THREE.Scene()
                camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.01, 1000 )
                camera.position.z = -20
                camera.position.y = 30
                camera.position.x = 0

                renderer = new THREE.WebGLRenderer({alpha: true})
                renderer.setPixelRatio( window.devicePixelRatio )
                renderer.setSize( window.innerWidth, window.innerHeight )
                renderer.autoClear = false
                canvas.appendChild( renderer.domElement )

                const light_env = new THREE.AmbientLight( 0xf0f0f0, 0.5 ); // soft white light
                scene.add( light_env )

                const light_point1 = new THREE.PointLight( 0xffffff, 0.8, 0 )
                light_point1.position.set( 200, 200, -300 )
                scene.add(light_point1)

                const light_point2 = new THREE.PointLight( 0xffffff, 0.5, 0 )
                light_point2.position.set( -200, 200, 300 )
                scene.add(light_point2)
                
                // Add plane
                const bg_geometry = new THREE.PlaneGeometry(100, 50);
                const bg_texture = new THREE.TextureLoader().load("assets/tamu.jpg")
                const bg_material = new THREE.MeshBasicMaterial({
                    // side: THREE.DoubleSide,
                    map: bg_texture
                })
                plane = new THREE.Mesh( bg_geometry.toNonIndexed(), bg_material )
                plane.rotation.set(-Math.PI / 2, 0, Math.PI)
                plane.updateMatrix()
                plane.geometry.applyMatrix4(plane.matrix)
                plane.rotation.set(0, 0, 0)
                plane.updateMatrix()
                scene.add( plane )
                
                // Add cloth
                const cloth_w = 20
                const cloth_h = 20
                cloth_corners = [0, cloth_dense, node_num - 1 - cloth_dense, node_num - 1]
                
                cloth_geo = new THREE.PlaneGeometry(cloth_w, cloth_h, cloth_dense, cloth_dense)
                cloth_geo.rotateX( Math.PI * 0.5 )
				cloth_geo.translate( cloth_pos.x, cloth_pos.y, cloth_pos.z)
                const cloth_material = new THREE.MeshLambertMaterial({
                    color: 0x75c3eb, 
                    side: THREE.DoubleSide
                })
                cloth = new THREE.Mesh(cloth_geo, cloth_material)
				cloth.castShadow = true
				cloth.receiveShadow = true
				scene.add(cloth)
				new THREE.TextureLoader().load("assets/grid.png", function (texture) {
					texture.wrapS = THREE.RepeatWrapping
					texture.wrapT = THREE.RepeatWrapping
					texture.repeat.set(cloth_dense, cloth_dense)
					cloth.material.map = texture
					cloth.material.needsUpdate = true
				})

                const dirs = [[0, 1], [1, 1], [1, 0], [1, -1]]
                for (let p0 = 0; i < cloth_dense; i++) {
                    for (let p1 = 0; j < cloth_dense; j++ ) {
                        for (let dir of dirs) {
                            const q0 = p0 + dir[0]
                            const q1 = p1 + dir[1]
                            if (q0 < 0 || q0 >= cloth_dense || q1 < 0 || q1 >= cloth_dense) {
                                continue
                            }

                            const pid = p0 * cloth_dense + p1
                            const qid = q0 * cloth_dense + q1

                            const ppos = node_pos[pid]
                            const qpos = node_pos[qid]
                            const l = ppos.distanceTo(qpos)
                            cloth_edges.push({
                                v0: pid,
                                v1: qid,
                                l0 = l
                            })
                        }
                    }
                }
                
                // Add stats and controls
                stats = new Stats();
				canvas.appendChild( stats.dom )

				window.addEventListener('resize', onWindowResize)

                window.addEventListener('keydown', function ( event ) {
                    switch ( event.keyCode ) {
                        case 81: // Q
                            cloth_move = 1
                            break
                        case 65: // A
                            cloth_move = - 1
                    }
                })

                window.addEventListener('keyup', function () {
                    cloth_move = 0
                })


                controls = new TrackballControls(camera, renderer.domElement);
                controls.dynamicDampingFactor = 0.5;
                controls.rotateSpeed = 2;
                controls.zoomSpeed = 2;
                controls.panSpeed = 3;
                
                // Add GUI
                // const gui = new GUI()
                // gui.add(params, 'pts_num', 1, 500)
                // gui.add(params, 'k_avoid', 0, 50)
                // gui.add(params, 'k_vmatch', 0, 30)
                // gui.add(params, 'k_center', 0, 30)
                // gui.add(params, 'r1', 0, 100)
                // gui.add(params, 'r2', 0, 100)
                // gui.add(params, 'obstacles')
                // gui.add(params, 'moving')
                // gui.add(params, "Reset")

                // gui.open()
                
            }

			function animate() {
				requestAnimationFrame( animate )

                const h = clock.getDelta()
                if (h_count < 30) {
                    render(h)
                }
                
                h_count = h_count + h

                controls.update()
				renderer.render( scene, camera )
                stats.update()
			}

            function render(h) {

                updateObjects(h)

                // update
                // if (params.obstacles && params.moving) {
                //     updateObstacles(h)
                // }
                
                // updateParticles(h)
                // updateGeo()
            }

            function updateObjects() {
                const node_pos = cloth_geo.getAttribute('position')
                const face_idx = cloth_geo.getIndex()
                
                const cloth_corners_pos = []
                for (let i = 0; i < 4; i++) {
                    const corner_idx = cloth_corners[i]
                    cloth_corners_pos.push([node_pos.getX(corner_idx), node_pos.getY(corner_idx), node_pos.getZ(corner_idx)])
                }

                const node_fn = new Array(node_num).fill(new THREE.Vector3(0, 0, 0))
                const node_vn = new Array(node_num).fill(new THREE.Vector3(0, 0, 0))

                for (let e of cloth_edges) {
                    const p0 = node_pos[e.v0]
                    const p1 = node_pos[e.v1]
                    const x01 = p1.clone().sub(p0)
                    const l = x01.length()
                    x01.normalize()
                    x01.multiplyScalar(spring * (l - e.l0))

                }

                console.log(face_idx)
                
                for (let i = 0; i < 4; i++) {
                    const corner_idx = cloth_corners[i]
                    pos.setX(corner_idx, cloth_corners_pos[i][0])
                    pos.setY(corner_idx, cloth_corners_pos[i][1] + cloth_move * 0.02)
                    pos.setZ(corner_idx, cloth_corners_pos[i][2])
                }
                
                cloth_geo.setAttribute('position', pos)
                cloth_geo.attributes.position.needsUpdate = true
            }

            function updateObstacles(h) {
                for (let obstacle of obstacles) {
                    
                    const pos_new = obstacle.mesh.position.clone()
                    pos_new.addScaledVector(obstacle.move, 50 * h)
                    if (pos_new.x > 300 || pos_new.x < -300) {
                        obstacle.move.x *= -1
                    }
                    if (pos_new.y > 400 || pos_new.y < 50) {
                        obstacle.move.y *= -1
                    }
                    obstacle.mesh.position.set(pos_new.x, pos_new.y, pos_new.z)
                }
            }

            function updateParticles(h) {
                
                
                // Get boundary faces
                let boundary_faces = getFaces(plane, true)
                
                face_len = boundary_faces.length
                // console.log(plane, boundary_faces)

                // Update pts position
                for (let p1 of pts) {
                    
                    let acc_avoid_sum = new THREE.Vector3(0, 0, 0)
                    let acc_vmatch_sum = new THREE.Vector3(0, 0, 0)
                    let acc_center_sum = new THREE.Vector3(0, 0, 0)
                    
                    // Interact with obstacles
                    if (params.obstacles) {
                        for (let obstacle of obstacles) {
                            const d = p1.pos.clone()
                            d.sub(obstacle.mesh.position)
                            const d_len = d.length()
                            d.normalize()
                            if (d_len < obstacle.size * 4) {
                                acc_avoid_sum.addScaledVector(d, 100 * Math.exp(Math.min(15, 1 / Math.max(0, d_len - obstacle.size))))
                            }
                        }
                    }

                    // console.log("acc_avoid_sum", acc_avoid_sum)

                    // Interact with boundaries
                    const xpc = p1.pos.clone()
                    xpc.sub(boundary_center)
                    const dpc = xpc.length()
                    xpc.normalize()
                    if (dpc > boundary_r) {
                        acc_avoid_sum.addScaledVector(xpc, -1 * Math.exp(Math.min(10, dpc-boundary_r)))
                    }

                    // Interact with points
                    for (let p2 of pts) {
                        
                        const x12 = p1.pos.clone()
                        x12.sub(p2.pos)
                        const v21 = p2.velocity.clone()
                        v21.sub(p1.velocity)
                        const d12 = x12.length()
                        
                        const acc_avoid = x12.clone()
                        const acc_vmatch = v21.clone()
                        const acc_center = x12.clone()

                        let k_d = 0
                        if (d12 < params.r1) {
                            k_d = 1
                        } else if (d12 < params.r2) {
                            k_d = (params.r2 - d12) / (params.r2 - params.r1)
                        } else if (d12 > params.r2) {
                            k_d = 0
                        }

                        acc_avoid_sum.addScaledVector(acc_avoid, params.k_avoid * k_d)
                        acc_vmatch_sum.addScaledVector(acc_vmatch, params.k_vmatch * k_d)
                        acc_center_sum.addScaledVector(acc_center, params.k_center * k_d)

                    }


                    // console.log("acc_sub", acc_avoid_sum, acc_vmatch_sum, acc_center_sum)

                    const acc = new THREE.Vector3(0, 0, 0)

                    let acc_r = acc_max
                    let acc_l = Math.min(acc_r, acc_avoid_sum.length())
                    acc_avoid_sum.normalize()
                    acc.addScaledVector(acc_avoid_sum, acc_l)

                    acc_r = acc_max - acc.length()
                    acc_l = Math.min(acc_r, acc_vmatch_sum.length())
                    acc_vmatch_sum.normalize()
                    acc.addScaledVector(acc_vmatch_sum, acc_l)
                    
                    // console.log("acc_r", acc.length(), acc_r)
                    acc_r = acc_max - acc.length()
                    acc_l = Math.min(acc_r, acc_center_sum.length())
                    acc_center_sum.normalize()
                    acc.addScaledVector(acc_center_sum, acc_l)
                    
                    acc.addScaledVector(p1.velocity, -air_resitance)

                    p1.velocity.addScaledVector(acc, h)
                    p1.velocity.clampLength(10, 1000)
                    p1.pos.addScaledVector(p1.velocity, h)

                }

            }

            function updateGeo() {

                const pos = cloth.geometry.getAttribute('position')
                const y0 = pos.getY()
                pos.setY(10)

                // const pos_list = []
                // const color_list = []
                // const size_list = []

                // for (let p of pts) {
                //     pos_list.push(p.pos.x, p.pos.y, p.pos.z)
                //     color_list.push(p.color.r, p.color.g, p.color.b)
                //     size_list.push(p.size)
                // }

                // pts_geo.setAttribute('position', new THREE.Float32BufferAttribute(pos_list, 3))
                // pts_geo.setAttribute('color', new THREE.Float32BufferAttribute(color_list, 3))
                // pts_geo.setAttribute('size', new THREE.Float32BufferAttribute(size_list, 1))

                // pts_geo.attributes.position.needsUpdate = true
                // pts_geo.attributes.color.needsUpdate = true
                // pts_geo.attributes.size.needsUpdate = true
            }

            function getFaces(mesh, invert_normal=false) {
                const vertices = mesh.geometry.getAttribute("position")
                let faces = []
                
                console.log("count", vertices.count)
                for (let i = 0; i < vertices.count; i += 3) {
                    let tri = []
                    for (let j = 0; j < 3; j ++) {
                        const base = i + j
                        const v = new THREE.Vector3(vertices.getX(base), vertices.getY(base), vertices.getZ(base))
                        v.add(mesh.position)
                        tri.push(v)
                    }
                    if (invert_normal) {
                        faces.push(new THREE.Triangle(tri[0], tri[2], tri[1]))
                    } else {
                        faces.push(new THREE.Triangle(tri[0], tri[1], tri[2]))
                    }
                }

                return faces
            }

            function onWindowResize() {

                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                camera.lookAt( scene.position );

                renderer.setSize( window.innerWidth, window.innerHeight );
                
                controls.handleResize();

            }


		</script>

	</body>
</html>